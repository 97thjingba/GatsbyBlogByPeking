{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog2/blog-2/","webpackCompilationHash":"d011f23c0606783f16eb","result":{"data":{"markdownRemark":{"html":"<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e16bb2436f0152d5d7fe7bc61c01514b/4aca8/img-5.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 728px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 46.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe9Ng0f/xAAWEAADAAAAAAAAAAAAAAAAAAAAICH/2gAIAQEAAQUCKv8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBABAAMBAAAAAAAAAAAAAAAAAQARICH/2gAIAQEAAT8hRvkFMCsf/9oADAMBAAIAAwAAABAwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEAAgMAAAAAAAAAAAAAABEBABAhMXH/2gAIAQEAAT8QAVFuSFeEuAG33U61/9k='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"img 5\"\n        title=\"\"\n        src=\"/static/e16bb2436f0152d5d7fe7bc61c01514b/e2ef7/img-5.jpg\"\n        srcset=\"/static/e16bb2436f0152d5d7fe7bc61c01514b/03ec9/img-5.jpg 182w,\n/static/e16bb2436f0152d5d7fe7bc61c01514b/3dea6/img-5.jpg 364w,\n/static/e16bb2436f0152d5d7fe7bc61c01514b/e2ef7/img-5.jpg 728w,\n/static/e16bb2436f0152d5d7fe7bc61c01514b/58232/img-5.jpg 1092w,\n/static/e16bb2436f0152d5d7fe7bc61c01514b/9cac1/img-5.jpg 1456w,\n/static/e16bb2436f0152d5d7fe7bc61c01514b/4aca8/img-5.jpg 2000w\"\n        sizes=\"(max-width: 728px) 100vw, 728px\"\n      />\n  </span>\n  </a></p>\n<h1>组件初始化阶段</h1>\n<p>constructor\n在该阶段组件中的构造方法 constructor() 接受 props 接收父组件传下来的 props。还可以在 constructor() 内部定义定义this.state 的初始内容。注意：在组件中写了 constructor 方法就必须在里面使用 super()，并且应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。</p>\n<pre><code>constructor(props) {\n  super(props)\n  console.log(this.props) // 在内部可以使用props\n  this.state = {\n    //定义state初始值\n  }\n}\n</code></pre>\n<h1>组件挂载阶段</h1>\n<p>componentWillMount\n在组件将要挂载到 DOM 前调用，只会被调用一次，在该方法中修改 state 的值，并不会引起组件重新渲染。(数据请求等异步操作不建议写在该方法内，异步操作可能阻塞 UI)。</p>\n<pre><code>componentWillMount(){}\n</code></pre>\n<p>render()\n该函数会创建一个虚拟 DOM，用来表示组件的输出。只能通过 this.props 和 this.state 访问数据，且不能在里面执行 this.setState 更该组件状态。在 render 中可以返回 null、false 或者任何 React 组件，只能出现一个顶级组件，不能返回一组元素(在 react16 中有所改善，可以返回一组元素或单个字符串)。</p>\n<pre><code>Render(){\n    return (\n        // react组件\n  )\n}\n</code></pre>\n<p>componentDidMount\n组件挂载到 Dom 后调用，且只调用一次。此时组件已经生成对应的 DOM 结构，可以在该函数中通过ReactDOM.findDOMNode()访问到真实的 DOM 或者通过 this.refs.[refName] 属性获取真实 DOM 。(数据请求等异步操作建议写在该方法内)</p>\n<pre><code>componentDidMount() {\n  // 进行异步数据请求或者获取dom\n}\n</code></pre>\n<h1>组件更新阶段</h1>\n<p>componentWillReceiveProps\n该函数接受一个参数 nextProps,当父组件重传props时会调用。拿到新的 props 与旧的 props 来比较是否变化，若变化可以通过 this.setState 更新 state。当然也可以不比较新旧 props 值直接更新 state。</p>\n<pre><code>componentWillReceiveProps(nextProps) {\n  // 示例\n  if (nextProps.state !== this.props.state) {\n     this.setState({\n       state: nextProps.state \n     });\n  }\n}\n</code></pre>\n<p>官方提示：在componentWillReceiveProps中调用 this.setState() 将不会引起第二次渲染。</p>\n<p>由于每次子组件接收到新的props，都会重新渲染一次，除非你使用 shouldComponentUpdate 来阻止重新渲染，但是你可以 componentWillReceiveProps 中根据新的 props 更新 state，虽然更新state也会触发一次重新渲染，但并不会触发额外的render。</p>\n<p>shouldComponentUpdate(nextProps,nextState)\n该函数是唯一可以控制组件渲染的生命周期。如果 props 和 state 的改变不需要重新渲染组件。则可以在该函数内返回 false，阻止组件的重新渲染。为了优化组件性能，减少组件的不必要渲染。</p>\n<pre><code>shouldComponentUpdate(nextProps, nextState){\n  // return true 更新组件\n  // return false 则不更新组件\n}\n</code></pre>\n<p>componentWillUpdate(nextProps,nextState)\nshouldComponentUpdate 方法返回 true 后，在组件即将进行重新渲染前调用该函数(注意不要里面去更新 props 或者 state，会导致组件进入死循环),在这之后会调用 render 方法进行重新渲染。</p>\n<pre><code>componentWillUpdate(nextProps,nextState) {\n  // 不要在此处更新props或state\n}\n</code></pre>\n<p>componentDidUpdate(prevProps,prevState)\n组件被重新渲染后该方法会被调用，可以拿到更新前的 props 和 state 。除了首次渲染时调用的componentDidMount，之后每次渲染都会调用该函数。和 componentDidMount 类似的是可以在这里操作更新后的DOM。</p>\n<pre><code>componentDidUpdate(prevProps,prevState) {}\n</code></pre>\n<h1>组件卸载阶段</h1>\n<p>componentWillUnmount\n该函数在组件卸载前被调用，可以在执行一些清理工作，比如清除组件中使用的定时器或者事件监听器，以避免引起内存泄漏。</p>\n<pre><code>componentWillUnmount() {\n  // 清除定时器或事件监听器\n}\n</code></pre>\n<p>react16的生命周期\nreact16的生命周期新引入了三个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate，componentDidCatch,弃用的三个生命周期函数：componentWillMount、componentWillReceivePorps，componentWillUpdate。其他的生命周期功能与前面介绍的相同。</p>\n<p>getDerivedStateFromProps(props, state)\n该函数在组件挂载阶段和后续更新阶段调用，根据 props 和 state 两个参数，计算出预期的状态改变，返回一个对象表示新的 state进行更新；如果不需要更新，返回 null 即可。该函数用来替代 componentWillReceiveProps。</p>\n<pre><code>static getDerivedStateFromProps(props, state) {\n  //根据props和state计算出预期的状态改变，返回结果会被送给setState\n}\n</code></pre>\n<p>getSnapshotBeforeUpdate(prevProps, prevState)\n该函数在render之后被调用，可以读取但无法使用DOM的时候。它使得组件能在发生更改之前从 DOM 中捕获一些信息(例如，滚动位置)。返回值将作为componentDidUpdate的第三个参数。该函数配合componentDidUpdate, 可以替代componentWillUpdate。</p>\n<pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate');\n    return 'react16';\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('snapshot = ', snapshot);\n  }\n</code></pre>\n<p>static getDerivedStateFromError()\n此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state。</p>\n<pre><code>static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染可以显降级 UI\n    return { hasError: true };\n  }\n</code></pre>\n<p>componentDidCatch(error，info)\n任何一处的javascript会触发该函数。</p>\n<pre><code>componentDidCatch(error, info) {\n  // 获取到javascript错误\n}\n</code></pre>\n<p>总结\nreact16更新后的生命周期可以总结为：</p>\n<p>组件挂载阶段</p>\n<p>constructor</p>\n<p>getDerivedStateFromProps</p>\n<p>render</p>\n<p>componentDidMount</p>\n<p>组件更新阶段</p>\n<p>getDerivedStateFromProps</p>\n<p>shouldComponentUpdate</p>\n<p>render</p>\n<p>getSnapshotBeforeUpdate</p>\n<p>componentDidUpdate</p>","frontmatter":{"title":"React生命周期","image":{"publicURL":"/static/img-two-be5a370e406c5fb83da94f510c0eee15.jpg"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog2/blog-2/"}}}